"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = exports.genValueStr = void 0;
const type_1 = require("./parse/type");
const filterEmptyText = (node) => !(node.type === type_1.NODE_TYPES.TEXT && !node.textContent.trim());
const genValueStr = (key, value, compress = false) => {
    if (value === true) {
        return key;
    }
    value = value.trim();
    const space = compress ? "" : " ";
    const reg = /\{\{\s*(.+)\s*\}\}/g;
    let temVal = /^(bind|catch).+/g.test(key)
    let val;
    if (temVal) {
        val = value.replace(reg, (_, s) => s.trim())
    } else {
        if ((/^wx\:.+/g.test(key) && /^wx\:key/g.test(key) && !reg.test(value)) || (/^wx\:.+/g.test(key) && /^wx\:for\-item/g.test(key) && !reg.test(value)) || (/^wx\:.+/g.test(key) && /^wx\:for\-index/g.test(key) && !reg.test(value))) {
            val = `${value}`
        } else if (/^wx\:.+/g.test(key) && !reg.test(value)) {
            val = `{{${space}${value}${space}}}`
        } else {
            val = value
        }
    }
    // const val = /^(bind|catch).+/g.test(key)
    //     ? value.replace(reg, (_, s) => s.trim())
    //     : /^wx\:.+/g.test(key) && !reg.test(value)
    //         ? `{{${space}${value}${space}}}`
    //         : value;
    return `${key}="${(compress
        ? val
        : val.replace(reg, (_, s) => `{{${space}${s.trim()}${space}}}`))}"`;
};
exports.genValueStr = genValueStr;
function _serialize(node, config = {}, prevTab = "\n") {
    var _a, _b;
    const { maxWidth = 120, compress } = config;
    let nextTab = prevTab + "\t";
    const serializeByType = {
        [type_1.NODE_TYPES.TEXT](node) {
            const text = node.textContent;
            if (node.parentNode.tagName === "text")
                return text;
            return text.trim() || "";
        },
        [type_1.NODE_TYPES.COMMENT](node) {
            if (compress)
                return "";
            return `<!--${node.comment}-->`;
        },
        [type_1.NODE_TYPES.ELEMENT](node) {
            var _a;
            const tagName = node.tagName || "";
            const keys = Object.keys(node.attributes);
            const attrs = keys.map((name) => {
                return exports.genValueStr(name, node.attributes[name], compress);
            });
            let attrsString = attrs.join(" ");
            let isBreakAttr = !compress && (attrsString === null || attrsString === void 0 ? void 0 : attrsString.length) > maxWidth;
            if (tagName === "text") {
                prevTab = "";
                nextTab = "";
                isBreakAttr = false;
            }
            const beforeEndStr = isBreakAttr ? prevTab : "";
            const beginTabEnd = beforeEndStr + ">";
            if (attrsString) {
                if (isBreakAttr) {
                    attrsString = nextTab + attrs.join(nextTab);
                }
                else {
                    attrsString = " " + attrsString;
                }
            }
            if (node.selfClosing) {
                return `<${tagName}${attrsString}${isBreakAttr ? beforeEndStr : " "}/>`;
            }
            if (node.childNodes.length) {
                const nodes = node.childNodes.filter(filterEmptyText);
                const isSingleText = nodes.length === 1 &&
                    nodes[0].type === type_1.NODE_TYPES.TEXT &&
                    ((_a = nodes[0].textContent) === null || _a === void 0 ? void 0 : _a.length) < maxWidth;
                let childNodesString = nodes
                    .map((v) => {
                    return _serialize(v, config, nextTab);
                })
                    .join(compress ? "" : nextTab);
                if (!compress && childNodesString) {
                    childNodesString =
                        (isSingleText ? "" : nextTab) +
                            childNodesString +
                            (isSingleText ? "" : prevTab);
                }
                return `<${tagName || ""}${attrsString}${beginTabEnd}${childNodesString}</${tagName}>`;
            }
            return `<${tagName}${attrsString}${beginTabEnd}</${tagName}>`;
        },
        // [NODE_TYPES.CDATA_SECTION](node) {
        //   throw new Error('Implement');
        // },
    };
    if (serializeByType[node === null || node === void 0 ? void 0 : node.type]) {
        return serializeByType[node.type](node);
    }
    const childNodes = ((_a = node) === null || _a === void 0 ? void 0 : _a.childNodes) || [];
    if (childNodes.length)
        return exports.generate((_b = node) === null || _b === void 0 ? void 0 : _b.childNodes, config);
}
const generate = (node, config) => {
    const { compress } = config;
    const baseTab = `\n`;
    if (Array.isArray(node) && node.length) {
        return node
            .filter(filterEmptyText)
            .map((v) => _serialize(v, config))
            .join(compress ? "" : baseTab);
    }
    return _serialize(node, config, baseTab);
};
exports.generate = generate;
