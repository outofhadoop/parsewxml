"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const common_1 = require("../common");
const check_1 = require("./check");
const nodes_1 = require("./nodes");
const token_1 = require("./token");
const type_1 = require("./type");
const parse = (str) => {
    function ensureValidNode() {
        if (!node) {
            common_1.throwError("Unexpected null node");
        }
    }
    const root = {
        type: type_1.NODE_TYPES.ROOT,
        childNodes: [],
    };
    let parent = root;
    let node = null;
    let attributeName = "";
    const stateMachine = {
        [type_1.TYPES.TEXT](text) {
            parent.childNodes.push(new nodes_1.TextNode(text, parent));
        },
        [type_1.TYPES.TAG_OPEN](text) {
            // if (closing) {
            //   const tagName = (parent as any)?.tagName;
            //   if (text !== tagName) {
            //     console.info(`${tagName} 与 ${text}不一致，将被替换为 ${tagName}`);
            //   }
            //   return;
            // }
            node = new nodes_1.ElementNode({ tagName: text });
        },
        [type_1.TYPES.TAG_CLOSE](closing, selfClosing) {
            if (attributeName) {
                node.attributes[attributeName] = true;
                attributeName = "";
            }
            if (closing && selfClosing) {
                common_1.throwError("Unexpected closing with selfClosing. e.g. </tag />");
            }
            if (selfClosing) {
                // 防止 < />的出现
                ensureValidNode();
                node.selfClosing = true;
                parent.childNodes.push(node);
                node = null;
                return;
            }
            if (closing) {
                node = parent;
                // < />出现在 root 的直接子元素， 会导致 node 为空
                parent = node.parentNode || root;
                node.closing = true;
                return;
            }
            parent.childNodes.push(node);
            node.parentNode = parent || root;
            parent = node;
            node = null;
        },
        [type_1.TYPES.ATTRIBUTE_NAME](text) {
            attributeName = text;
            node.attributes[attributeName] = true;
        },
        [type_1.TYPES.ATTRIBUTE_VALUE](text) {
            node.attributes[attributeName] = text;
            attributeName = "";
        },
        [type_1.TYPES.COMMENT](comment) {
            parent.childNodes.push(new nodes_1.CommentNode(comment));
        },
    };
    function traverse(type, ...args) {
        const action = stateMachine[type];
        // @ts-ignore
        action(...args);
    }
    token_1.token(str, traverse, () => ({ node, parent }));
    check_1.checkValidate(root);
    return root;
};
exports.parse = parse;
